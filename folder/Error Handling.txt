<div>Error Handling:</div><div><br></div><div>As such C programming does not provide direct support for error handling but being a system programming language, it provides you access at lower level in the&nbsp;</div><div><br></div><div>form of return values. Most of the C or even Unix function calls return -1 or NULL in case of any error and an error code errno is set which is global&nbsp;</div><div><br></div><div>variable and indicates an error occurred during any function call. You can find various error codes defined in &lt;error.h&gt; header file.</div><div>So a C programmer can check the returned values and can take appropriate action depending on the return value. As a good practice, developer should set errno&nbsp;</div><div><br></div><div>to 0 at the time of initialization of the program. A value of 0 indicates that there is no error in the program.</div><div>The errno, perror() and strerror()</div><div>----------------------------------</div><div>The C programming language provides perror() and strerror() functions which can be used to display the text message associated with errno.</div><div><br></div><div>&nbsp; &nbsp; The perror() function displays the string you pass to it, followed by a colon, a space, and then the textual representation of the current errno value.</div><div><br></div><div>&nbsp; &nbsp; The strerror() function, which returns a pointer to the textual representation of the current errno value.</div><div><br></div><div>Let's try to simulate an error condition and try to open a file which does not exist. Here I'm using both the functions to show the usage, but you can use one or&nbsp;</div><div><br></div><div>more ways of printing your errors. Second important point to note is that you should use stderr file stream to output all the errors.</div><div><br></div><div>#include &lt;stdio.h&gt;</div><div>#include &lt;errno.h&gt;</div><div>#include &lt;string.h&gt;</div><div><br></div><div>extern int errno ;</div><div><br></div><div>int main ()</div><div>{</div><div>&nbsp; &nbsp;FILE * pf;</div><div>&nbsp; &nbsp;int errnum;</div><div>&nbsp; &nbsp;pf = fopen ("unexist.txt", "rb");</div><div>&nbsp; &nbsp;if (pf == NULL)</div><div>&nbsp; &nbsp;{</div><div>&nbsp; &nbsp; &nbsp; errnum = errno;</div><div>&nbsp; &nbsp; &nbsp; fprintf(stderr, "Value of errno: %d\n", errno);</div><div>&nbsp; &nbsp; &nbsp; perror("Error printed by perror");</div><div>&nbsp; &nbsp; &nbsp; fprintf(stderr, "Error opening file: %s\n", strerror( errnum ));</div><div>&nbsp; &nbsp;}</div><div>&nbsp; &nbsp;else</div><div>&nbsp; &nbsp;{</div><div>&nbsp; &nbsp; &nbsp; fclose (pf);</div><div>&nbsp; &nbsp;}</div><div>&nbsp; &nbsp;return 0;</div><div>}</div><div><br></div><div>When the above code is compiled and executed, it produces the following result:</div><div><br></div><div>Value of errno: 2</div><div>Error printed by perror: No such file or directory</div><div>Error opening file: No such file or directory</div><div><br></div><div>Divide by zero errors</div><div>---------------------</div><div><br></div><div>It is a common problem that at the time of dividing any number, programmers do not check if a divisor is zero and finally it creates a runtime error.</div><div><br></div><div>The code below fixes this by checking if the divisor is zero before dividing:</div><div><br></div><div>#include &lt;stdio.h&gt;</div><div>#include &lt;stdlib.h&gt;</div><div><br></div><div>main()</div><div>{</div><div>&nbsp; &nbsp;int dividend = 20;</div><div>&nbsp; &nbsp;int divisor = 0;</div><div>&nbsp; &nbsp;int quotient;</div><div>&nbsp;</div><div>&nbsp; &nbsp;if( divisor == 0){</div><div>&nbsp; &nbsp; &nbsp; fprintf(stderr, "Division by zero! Exiting...\n");</div><div>&nbsp; &nbsp; &nbsp; exit(-1);</div><div>&nbsp; &nbsp;}</div><div>&nbsp; &nbsp;quotient = dividend / divisor;</div><div>&nbsp; &nbsp;fprintf(stderr, "Value of quotient : %d\n", quotient );</div><div><br></div><div>&nbsp; &nbsp;exit(0);</div><div>}</div><div><br></div><div>When the above code is compiled and executed, it produces the following result:</div><div><br></div><div>Division by zero! Exiting...</div><div><br></div><div>Program Exit Status</div><div>-------------------</div><div><br></div><div>It is a common practice to exit with a value of EXIT_SUCCESS in case of programming is coming out after a successful operation. Here EXIT_SUCCESS is a&nbsp;</div><div><br></div><div>macro and it is defined as 0.</div><div><br></div><div>If you have an error condition in your program and you are coming out then you should exit with a status EXIT_FAILURE which is defined as -1. So let's write&nbsp;</div><div><br></div><div>above program as follows:</div><div><br></div><div>#include &lt;stdio.h&gt;</div><div>#include &lt;stdlib.h&gt;</div><div><br></div><div>main()</div><div>{</div><div>&nbsp; &nbsp;int dividend = 20;</div><div>&nbsp; &nbsp;int divisor = 5;</div><div>&nbsp; &nbsp;int quotient;</div><div>&nbsp;</div><div>&nbsp; &nbsp;if( divisor == 0){</div><div>&nbsp; &nbsp; &nbsp; fprintf(stderr, "Division by zero! Exiting...\n");</div><div>&nbsp; &nbsp; &nbsp; exit(EXIT_FAILURE);</div><div>&nbsp; &nbsp;}</div><div>&nbsp; &nbsp;quotient = dividend / divisor;</div><div>&nbsp; &nbsp;fprintf(stderr, "Value of quotient : %d\n", quotient );</div><div><br></div><div>&nbsp; &nbsp;exit(EXIT_SUCCESS);</div><div>}</div><div><br></div><div>When the above code is compiled and executed, it produces the following result:</div><div><br></div><div>Value of quotient : 4</div>